<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrum Notes</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/vuedraggable@4.1.0/dist/vuedraggable.umd.js"></script>
</head>
<body>

<div id="app">
    <div v-if="!dbLoaded" style="padding: 20px; font-family: sans-serif;">ğŸ”„ Loading App & Database...</div>
    
    <div v-else>
        <h1>ğŸ“‹ Scrum Notes</h1>
        <nav>
            <button @click="view = 'home'">ğŸ  Home</button>
            <button @click="view = 'edit'">âœï¸ Edit Tasks</button>
        </nav>
        <hr>

        <div v-if="view === 'home'">
            <h2>ğŸ  Dashboard</h2>
            <div v-for="parent in titles" :key="parent.id" style="border: 1px solid #ccc; margin-bottom: 10px; padding: 10px;">
                <details>
                    <summary><strong>{{ parent.text }}</strong></summary>
                    <div style="padding-left: 20px;">
                        <h4>â³ To Do</h4>
                        <ul>
                            <li v-for="item in getIncomplete(parent.id)" :key="item.id">{{ item.text }}</li>
                        </ul>
                        <h4>âœ… Completed</h4>
                        <ul>
                            <li v-for="item in getComplete(parent.id)" :key="item.id"><s>{{ item.text }}</s></li>
                        </ul>
                        <button @click="prepareCleanup(parent.id)">ğŸ§¹ Cleanup</button>
                    </div>
                </details>
            </div>

            <div v-if="cleanupList.length > 0" style="background: #fff3f3; border: 2px solid red; padding: 15px; margin-top: 20px;">
                <h3>âš ï¸ Confirm Deletion</h3>
                <ul>
                    <li v-for="item in cleanupList" :key="item.id">
                        {{ item.parentId === 0 ? 'ğŸ“ [TITLE]' : 'ğŸ“„' }} {{ item.text }}
                    </li>
                </ul>
                <button @click="executeCleanup">ğŸ”¥ Confirm Delete All</button>
                <button @click="cleanupList = []">âŒ Cancel</button>
            </div>
        </div>

        <div v-if="view === 'edit'">
            <h2>âœï¸ Edit/Create</h2>
            <label>Title:</label>
            <input list="title-suggestions" v-model="selectedTitleText" @change="handleTitleSelect" placeholder="Select or type new title...">
            <datalist id="title-suggestions">
                <option v-for="t in titles" :value="t.text"></option>
            </datalist>
            <button @click="createNewTitle">â• Create Title</button>

            <div v-if="currentParentId" style="margin-top: 20px;">
                <h3>Active: {{ activeParent?.text }}</h3>
                <div style="margin-bottom: 15px;">
                    <input v-model="newChildText" placeholder="New task..." @keyup.enter="addChild">
                    <button @click="addChild">â• Add</button>
                </div>

                <p><i>Drag â˜° to reorder. Completed items stay at bottom.</i></p>
                <draggable 
                    v-model="editList" 
                    item-key="id" 
                    handle=".handle"
                    @end="syncOrder">
                    <template #item="{element}">
                        <div style="display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #eee;">
                            <span class="handle" style="cursor: move; margin-right: 10px;">â˜°</span>
                            <input type="checkbox" v-model="element.completed" @change="updateItem(element)">
                            <input type="text" v-model="element.text" @blur="updateItem(element)" style="flex-grow: 1; margin: 0 10px;">
                            <button @click="deleteItem(element.id)">ğŸ—‘ï¸</button>
                        </div>
                    </template>
                </draggable>
            </div>
        </div>
    </div>
</div>

<script>
const { createApp, ref, onMounted, computed, watch } = Vue;

const app = createApp({
    components: {
        'draggable': window.vuedraggable
    },
    setup() {
        const view = ref('home');
        const items = ref([]);
        const dbLoaded = ref(false);
        const db = ref(null);
        
        const selectedTitleText = ref('');
        const currentParentId = ref(null);
        const newChildText = ref('');
        const cleanupList = ref([]);
        const editList = ref([]); // Local ref for draggable to mutate

        // IndexedDB
        const initDB = () => {
            const request = indexedDB.open("ScrumNotesDB", 2);
            request.onupgradeneeded = (e) => {
                const database = e.target.result;
                if (!database.objectStoreNames.contains("items")) {
                    database.createObjectStore("items", { keyPath: "id", autoIncrement: true });
                }
            };
            request.onsuccess = (e) => {
                db.value = e.target.result;
                fetchItems().then(() => dbLoaded.value = true);
            };
        };

        const fetchItems = () => {
            return new Promise((resolve) => {
                const transaction = db.value.transaction(["items"], "readonly");
                const store = transaction.objectStore("items");
                const request = store.getAll();
                request.onsuccess = () => {
                    items.value = request.result;
                    resolve();
                };
            });
        };

        const saveItem = (item) => {
            const transaction = db.value.transaction(["items"], "readwrite");
            const store = transaction.objectStore("items");
            store.put(JSON.parse(JSON.stringify(item)));
            transaction.oncomplete = () => fetchItems();
        };

        const updateItem = (item) => saveItem(item);

        const deleteItem = (id) => {
            const transaction = db.value.transaction(["items"], "readwrite");
            const store = transaction.objectStore("items");
            store.delete(id);
            transaction.oncomplete = () => fetchItems();
        };

        // Computed
        const titles = computed(() => items.value.filter(i => i.parentId === 0).sort((a, b) => a.index - b.index));
        const activeParent = computed(() => items.value.find(i => i.id === currentParentId.value));

        // Sorting Logic
        const sortItems = (list) => {
            return [...list].sort((a, b) => {
                if (a.completed !== b.completed) return a.completed ? 1 : -1;
                return a.index - b.index;
            });
        };

        const getChildren = (pid) => items.value.filter(i => i.parentId === pid);
        const getIncomplete = (pid) => getChildren(pid).filter(i => !i.completed).sort((a, b) => a.index - b.index);
        const getComplete = (pid) => getChildren(pid).filter(i => i.completed).sort((a, b) => a.index - b.index);

        // Watchers
        watch([currentParentId, items], () => {
            if (currentParentId.value) {
                const children = getChildren(currentParentId.value);
                editList.value = sortItems(children);
            }
        }, { immediate: true });

        // Actions
        const createNewTitle = () => {
            if (!selectedTitleText.value) return;
            const exists = titles.value.find(t => t.text === selectedTitleText.value);
            if (exists) {
                currentParentId.value = exists.id;
            } else {
                const newItem = { parentId: 0, text: selectedTitleText.value, completed: false, index: titles.value.length };
                saveItem(newItem);
            }
        };

        const handleTitleSelect = () => {
            const found = titles.value.find(t => t.text === selectedTitleText.value);
            if (found) currentParentId.value = found.id;
        };

        const addChild = () => {
            if (!newChildText.value || !currentParentId.value) return;
            const newItem = {
                parentId: currentParentId.value,
                text: newChildText.value,
                completed: false,
                index: getChildren(currentParentId.value).length
            };
            saveItem(newItem);
            newChildText.value = '';
        };

        const syncOrder = () => {
            editList.value.forEach((item, idx) => {
                item.index = idx;
                updateItem(item);
            });
        };

        const prepareCleanup = (parentId) => {
            const children = getChildren(parentId);
            const completed = children.filter(c => c.completed);
            let toDelete = [...completed];
            if (children.length > 0 && children.length === completed.length) {
                toDelete.push(items.value.find(i => i.id === parentId));
            }
            cleanupList.value = toDelete;
        };

        const executeCleanup = () => {
            const transaction = db.value.transaction(["items"], "readwrite");
            const store = transaction.objectStore("items");
            cleanupList.value.forEach(i => store.delete(i.id));
            transaction.oncomplete = () => {
                cleanupList.value = [];
                fetchItems();
            };
        };

        onMounted(() => initDB());

        return {
            view, dbLoaded, titles, selectedTitleText, currentParentId, activeParent,
            newChildText, editList, cleanupList,
            getIncomplete, getComplete, createNewTitle, handleTitleSelect,
            addChild, updateItem, deleteItem, syncOrder, prepareCleanup, executeCleanup
        };
    }
}).mount('#app');
</script>
</body>
</html>
